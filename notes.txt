1. What is virtual environment and what problem it solves?

Ans: 
A virtual environment (often abbreviated as "virtualenv") is a tool in Python that helps to manage project-specific dependencies. It essentially creates an isolated environment for each project, allowing different projects to have their own set of dependencies, which can be different from each other and from the system-wide installed packages. 

2. Virtual environment jiss folder me banaya jaayega wo bass uss folfer tak hi simit rahega.

3. Key Aspects of Virtual Environments

   1. **Isolation**: Each virtual environment has its own installation directories and does not share dependencies with other virtual environments or the global Python installation.

   2. **Project-Specific Dependencies**: You can install dependencies specific to a project without affecting other projects or the global Python environment.

   3. **Consistency**: Virtual environments help maintain consistent dependencies across different development environments (e.g., development, testing, production), which reduces the "it works on my machine" problem.

4. Problems Solved by Virtual Environments

   1. **Dependency Conflicts**: Different projects may require different versions of the same package. Virtual environments prevent conflicts by isolating dependencies for each project.

   2. **Environment Reproducibility**: By using a virtual environment and a requirements file (like `requirements.txt`), you can easily reproduce the same environment across different machines and development stages.

   3. **Clean Global Environment**: Using virtual environments avoids cluttering the global Python installation with project-specific packages, making it easier to manage and avoid unintended interactions between projects.

   4. **Simplified Deployment**: Virtual environments help create consistent deployment environments, which can be crucial for applications running in production.

   5. **Security**: Isolating dependencies can enhance security by reducing the risk of conflicting or outdated packages affecting different projects.



5. **Creating a Virtual Environment**:
   ```sh
   python3 -m venv myenv
   ```
   This command creates a new directory named `myenv` containing the virtual environment.

6. **Activating a Virtual Environment**:
   - On Unix or MacOS:
     ```sh
     source myenv/bin/activate
     ```
     After this relaunch your terminal

6. **Deactivating a Virtual Environment**:
   ```sh
   deactivate
   ```

7. **Installing Packages in a Virtual Environment**:
   Once the virtual environment is activated, you can install packages using `pip`:
   ```sh
   pip3 install package_name
   ```

8. **Freezing Dependencies**:
   To generate a list of installed packages and their versions, use:
   ```sh
   pip3 freeze > requirements.txt
   ```

9. **Installing Dependencies from a File**:
   To install dependencies listed in a `requirements.txt` file, use:
   ```sh
   pip3 install --no-cache-dir -r requirements.txt
   ```

By using virtual environments, developers can ensure that their projects are more manageable, reproducible, and free from dependency conflicts.

10.  package we installed when using virtual environment , the code for all those packages will reside in the lib folder of virtual environment.

11. Use gitignore generators to generate gitignore for your project.

3. FastApi automaticallay converts the dictionary to json and sends it to the web browser.

4. HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as HTTP verbs. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be safe, idempotent, or cacheable.

GET
The GET method requests a representation of the specified resource. Requests using GET should only retrieve data. It does not have a request body.

HEAD
The HEAD method asks for a response identical to a GET request, but without the response body.

POST
The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.Has request body

PUT
The PUT method replaces all current representations of the target resource with the request payload.Has request body

DELETE
The DELETE method deletes the specified resource. It may or may not have request body.

CONNECT
The CONNECT method establishes a tunnel to the server identified by the target resource.

OPTIONS
The OPTIONS method describes the communication options for the target resource.

TRACE
The TRACE method performs a message loop-back test along the path to the target resource.

PATCH
The PATCH method applies partial modifications to a resource.Has request body.

5. FastAPI me route ka exact match hota hai naki prefix based match.

6. Get request can be seen in browser directly but not other requests.

7. Why we need schema?
Ans:
(a) Its pain to get all the values from the body.
(b) The client can send whatever data they want.
(c) The data isn't getting validated.
(d) We ultimately want client to send data in the format we expect.

8. Yadi koi field ko optional banana hai to uska default value dena jarrrri hai.

9. Pydantic model ko dictionry me convert karne ke liye use .dict 

10. In api naming always use the prural.

19. url se aane wala cheez str rahega.

20. 404 = Mot Found

21.  Status codes provide a clear and standardized way for servers to communicate the outcome of a request to clients (browsers, APIs, etc.).

22. When we delete something and pass 204 as status code we should not send any data back otherwise fastapi will throw error

23. __init__.py kisi bhi directory ko package banata hai

24. Kisis bhi folder ke andar yadi koi file import kar raha hai to __init__.py file ko uss folder me zaroor rakhna.

25. pytest -v

26. Pytest will not print any of the print statements . To do so you need to :
pytest -v -s. This will run all the tests. If you want to test some specific file then:
pytest -v -s path of file. If you want to disable warnings then use pytest -v -s --disable-warnings.
-v means verbose i.e show the output of execution.
pytest -v -s --disable-warnings -x (-x tells pytest to stop after one tets is failed)

27. If we want to run multiple test cases then we should use @pytes.mark.parameterize("var1,var2,res",[(1,2,3),(4,5,9)])
Here pass the same varibles var1,var2,res to function

28. I have folder called testing . Inside this folder , I have two folders code and tests. I want to import a from code in another file in tests fodler. How do I do that in python?

Ans: To import a module from one directory into another in Python, you need to ensure that the Python interpreter can locate the modules. Here's how you can achieve this:

### Project Structure
Assuming your project structure looks like this:
```
testing/
├── code/
│   └── a.py
└── tests/
    └── test_b.py
```
You want to import something from `a.py` (inside the `code` folder) into `test_b.py` (inside the `tests` folder).

### Step-by-Step Solution

1. **Ensure `testing` is a Package**: Create `__init__.py` files to make sure that directories are treated as packages. You may need to add `__init__.py` files if they are not already present:
    ```
    testing/
    ├── code/
    │   ├── __init__.py
    │   └── a.py
    └── tests/
        ├── __init__.py
        └── test_b.py
    ```

2. **Adjust Import Path**: In `test_b.py`, use relative or absolute imports.

### Using Absolute Imports
If `testing` is part of your Python path (i.e., you are running your script from the directory containing `testing` or have added it to `sys.path`), you can use an absolute import.

```python
# testing/tests/test_b.py

from testing.code import a

# Use functions or classes from a
a.some_function()
```

### Using Relative Imports
If `testing/tests/test_b.py` is in the same module hierarchy as `testing/code/a.py`, you can use relative imports.

```python
# testing/tests/test_b.py

from ..code import a

# Use functions or classes from a
a.some_function()
```

### Running the Script
When running `test_b.py`, ensure that the `testing` directory is in your Python path. You can do this by running the script from the parent directory of `testing` or by adjusting `sys.path` within the script.

#### Running from Parent Directory
Navigate to the directory that contains `testing` and run:
```sh
python -m testing.tests.test_b
```

#### Adjusting `sys.path`
Modify `sys.path` in your `test_b.py` to include the `testing` directory:
```python
# testing/tests/test_b.py

import sys
import os

# Add the parent directory of `tests` to sys.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from code import a

# Use functions or classes from a
a.some_function()
```

### Example Content for Files
Here's a simple example of what the contents of `a.py` and `test_b.py` might look like:

**`a.py`**:
```python
# testing/code/a.py

def some_function():
    print("Hello from a.py!")
```

**`test_b.py`**:
```python
# testing/tests/test_b.py

from testing.code import a  # Absolute import
# from ..code import a  # Relative import
# or using sys.path modification as shown above

a.some_function()
```

By following these steps, you can import modules from one directory into another within the same project.

27. ANy time you will receive an exception , it will cause to fail the test case. 

28. Exceptions should be hamdled as a separate test case.

29. assert statement kabhi bhi True hone par kuch return nahi karta hai aur program ko normally chalne deta hai par false hone par Exception raise karke program ko terminate karta hai.

30. fixtures:
In the context of software testing, particularly with frameworks like pytest, a **fixture** is a function that provides a fixed baseline environment for tests to run. This baseline can include setting up databases, files, or any state that is required for the tests to execute properly. Fixtures help in making the tests more reliable and easier to write by handling setup and teardown processes.

### Key Concepts of Fixtures

1. **Setup and Teardown**: Fixtures manage the setup before a test runs and the teardown after the test has completed. This ensures that each test runs in a consistent environment and that resources are properly cleaned up afterward.

2. **Reusability**: Fixtures can be reused across multiple tests. This reduces redundancy and makes the test code cleaner and easier to maintain.

3. **Scope**: Fixtures can have different scopes, determining how often the setup and teardown processes are performed. Common scopes include:
   - **Function**: The fixture is set up and torn down once per test function.
   - **Class**: The fixture is set up and torn down once per class of tests.
   - **Module**: The fixture is set up and torn down once per module.
   - **Session**: The fixture is set up and torn down once per session, meaning it lasts for the duration of the testing session.

4. **Parameterized Fixtures**: These allow you to run a single fixture with multiple sets of parameters, useful for testing various inputs.

### Example with pytest

Let's look at an example using pytest, a popular testing framework in Python:

#### Directory Structure
```
testing/
├── code/
│   └── a.py
└── tests/
    ├── __init__.py
    ├── conftest.py
    └── test_b.py
```

#### Content of `a.py`
```python
# testing/code/a.py

def add(x, y):
    return x + y
```

#### Content of `conftest.py`
`conftest.py` is a special configuration file for pytest that allows you to define fixtures that are available to all test files in the directory and its subdirectories.

```python
# testing/tests/conftest.py

import pytest

@pytest.fixture
def example_data():
    return {'x': 1, 'y': 2}
```

#### Content of `test_b.py`
```python
# testing/tests/test_b.py

from code.a import add

def test_add(example_data):
    result = add(example_data['x'], example_data['y'])
    assert result == 3
```

### Explanation

1. **Fixture Definition**:
   - In `conftest.py`, we define a fixture called `example_data` using the `@pytest.fixture` decorator. This fixture returns a dictionary with the keys `x` and `y`.

2. **Using the Fixture**:
   - In `test_b.py`, the test function `test_add` includes a parameter named `example_data`. pytest automatically recognizes this parameter and uses the `example_data` fixture, providing its return value to the test function.

3. **Test Execution**:
   - When `test_add` runs, pytest sets up the `example_data` fixture, passing its return value to the test function. The test function uses this data to perform its assertions.

### Benefits of Using Fixtures

- **Consistency**: Ensures that tests run in a consistent environment.
- **Maintainability**: Reduces duplication and makes it easier to update the setup code in one place.
- **Readability**: Makes test functions shorter and more focused on the actual testing logic.

Fixtures are a powerful feature of pytest and other testing frameworks, providing a structured and efficient way to manage the setup and teardown of test environments.

30. response object ko json me change karo tab usko access kar paaoge.

31.TestClient is used to test api. It acts as same way as request and we can send any request using it.

32. request.json() will show the request in readable format.

33. MagicMock is synchronous function. A coroutine is an asynchronous function like AsyncMock()

34. An event loop is when we let some stuff that takes a long time do it's thing in the background. And when it's all set, the 'event loop' will 'pick it up'." is the most helpful and intuitive definition of event loop I've heard.


35. Certainly! Let's break down the code and explain how decorators work in this context.

1. **Define a decorator function:**
   
   ```python
   def add_smiley(func):
       def wrapper():
           return func() + " :)"
       return wrapper
   ```
   
   Here, `add_smiley` is a decorator function. It takes another function (`func`) as an argument and returns a new function (`wrapper`). Inside `wrapper`, it calls the original function `func` and adds a smiley face to its output.

2. **Decorate the function with multiple decorators:**
   
   ```python
   @add_smiley
   @make_louder
   def greet():
       return "Hello"
   ```
   
   The `greet` function is decorated with two decorators: `add_smiley` and `make_louder`. This means that the output of `greet` will be processed first by `add_smiley`, and then by `make_louder`.

3. **Call the decorated function:**
   
   ```python
   print(greet())  # Output: HELLO!!! :)
   ```
   
   When `greet()` is called, it goes through the decorators. First, `add_smiley` adds a smiley face to the greeting, and then `make_louder` makes the greeting louder by converting it to uppercase and adding exclamation marks. The final output is "HELLO!!! :)".

In summary, decorators in Python allow us to modify the behavior of functions by wrapping them with additional functionality. Multiple decorators can be applied to a single function, and they are applied in the order they are listed, with the innermost decorator being applied first.

36. When a function has multiple decorators , the innermost decorator is applied first.

37. test_ se ftest file aur function ka naam suru hona chahiye.

38. In fastapi json is same as dict.

39. Yadi koi chhez kisi bar dependent hai to usko same file me hona chahiye ya import kiya hona chahiye.

40. 